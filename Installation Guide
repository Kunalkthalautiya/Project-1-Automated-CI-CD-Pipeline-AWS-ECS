# Automated CI/CD Pipeline - Complete GUI Installation Guide

## Jenkins, Docker, AWS ECS (Fargate) & Application Load Balancer

---

## üìö Table of Contents
1. [Introduction](#1-introduction)
2. [Why This Project Is Needed](#2-why-this-project-is-needed)
3. [Understanding CI/CD](#3-understanding-cicd)
4. [What This Project Solves](#4-what-this-project-solves)
5. [Benefits of This Project](#5-benefits-of-this-project)
6. [Tools & Technologies](#6-tools--technologies)
7. [High‚ÄëLevel Architecture](#7-highlevel-architecture)
8. [Internal Data & Control Flow](#8-internal-data--control-flow)
9. [Deployment Strategies & Zero Downtime](#9-deployment-strategies--zero-downtime)
10. [Security Best Practices & Common Mistakes](#10-security-best-practices--common-mistakes)
11. [Implementation Guide (Step‚Äëby‚ÄëStep GUI)](#11-implementation-guide-stepbystep-gui)
    - [STEP 1: Create EC2 Instance for Jenkins](#step-1-create-ec2-instance-for-jenkins-server)
    - [STEP 2: IAM Role Setup for Jenkins](#step-2-iam-role-setup-for-jenkins-ec2--ecr--ecs)
    - [STEP 3: Prepare EC2 Server](#step-3-prepare-ec2-server-for-jenkins--cicd)
    - [STEP 4: Install & Configure Jenkins](#step-4-install--configure-jenkins-on-ec2)
    - [STEP 5: Clone GitHub Repo in Jenkins](#step-5-clone-application-repository-in-jenkins)
    - [STEP 6: Build Docker Image (CI)](#step-6-build-docker-image-using-jenkins-pipeline-core-ci-step)
    - [STEP 7: Push Image to Amazon ECR](#step-7-push-docker-image-to-amazon-ecr)
    - [STEP 8: Create ECS Cluster (Fargate)](#step-8-create-ecs-cluster-aws-fargate)
    - [STEP 9: Create ECS Task Definition](#step-9-create-ecs-task-definition-fargate)
    - [STEP 10: Create ECS Service](#step-10-create-ecs-service-aws-fargate)
    - [STEP 11: Create Application Load Balancer](#step-11-create-application-load-balancer-alb)
    - [STEP 12: Create Target Group](#step-12-create-target-group-for-ecs-service)
    - [STEP 13: Attach Target Group to ALB Listener](#step-13-attach-target-group-to-ecs-service-enable-traffic-flow)
12. [Final Takeaway](#12-final-takeaway)

---

## 1. Introduction

### 1.1 What Is This Project?
This project demonstrates how to build a real‚Äëworld, production‚Äëgrade CI/CD pipeline that automatically deploys a containerized application to AWS using modern DevOps tools.

In simple terms, whenever a developer pushes code to GitHub, the system automatically:
- Builds the application
- Packages it into a Docker container
- Stores it securely
- Deploys it to the cloud
- Makes it available to users via a stable URL

All of this happens without any manual intervention using a CI/CD (Continuous Integration & Continuous Deployment) pipeline.

### 1.2 Real‚ÄëWorld Analogy
Think of this pipeline as a fully automated factory:
- **GitHub** ‚Üí Raw material arrives
- **Jenkins** ‚Üí Factory manager coordinating tasks
- **Docker** ‚Üí Packaging unit
- **AWS ECR** ‚Üí Warehouse for packages
- **AWS ECS (Fargate)** ‚Üí Delivery vehicles
- **Application Load Balancer** ‚Üí Traffic controller for customers

Once configured, every new version flows automatically to users.

### 1.3 Why This Project Matters in Industry
This is not a toy project. The same architecture is used by:
- SaaS companies
- Startups
- Large enterprises
- Microservices‚Äëbased platforms

Understanding this project means understanding:
- How real deployments happen
- How DevOps teams reduce risk
- How zero‚Äëdowntime releases are achieved

---

## 2. Why This Project Is Needed (Problem Explanation)

### 2.1 Traditional Deployment (Manual Way)
In traditional setups:
- Developer updates code
- Application is built manually
- Docker image is created manually
- Image is pushed manually
- ECS task definition updated manually
- Services restarted manually

This approach does **not** scale.

### 2.2 Problems with Manual Deployment
‚ùå Time‚Äëconsuming
‚ùå Human errors
‚ùå No consistency
‚ùå Not scalable
‚ùå No rollback safety

Manual deployment in production is risky and unprofessional.

### 2.3 Why Automation Is Mandatory
Modern applications:
- Change frequently
- Serve many users
- Must stay online 24/7

Automation ensures:
- Speed
- Safety
- Repeatability
- Reliability

---

## 3. Understanding CI/CD (Beginner ‚Üí Advanced)

### 3.1 Continuous Integration (CI)
**Definition:** Automatically building and validating code whenever changes are pushed.

**CI internally:**
- Pulls code from GitHub
- Builds the application
- Runs validations
- Ensures deployability

**Why CI matters:**
- Detects errors early
- Keeps main branch stable

### 3.2 Continuous Deployment (CD)
**Definition:** Automatically deploying verified code to production without manual approval.

Once CI succeeds:
- New version is deployed automatically
- Users get updates immediately

### 3.3 CI vs Continuous Delivery vs Continuous Deployment

| Term | Meaning |
|------|---------|
| CI | Build & validate code |
| Continuous Delivery | Ready for deployment (manual approval) |
| Continuous Deployment | Auto‚Äëdeploy to production |

This project uses **Continuous Deployment**.

### 3.4 Why CI/CD Is an Industry Standard
- Faster releases
- Safer deployments
- Easier rollbacks
- Better collaboration

---

## 4. What This Project Solves
This project builds a fully automated deployment pipeline that:
- Eliminates manual steps
- Uses containers for consistency
- Runs on serverless infrastructure
- Provides stable access via ALB
- Reflects real DevOps workflows

---

## 5. Benefits of This Project
‚úÖ Fully automated deployments
‚úÖ Zero‚Äëdowntime updates (conceptual)
‚úÖ Scalable container architecture
‚úÖ Stable DNS endpoint
‚úÖ Secure image storage (ECR)
‚úÖ Serverless execution (Fargate)
‚úÖ Strong DevOps foundation

---

## 6. Tools & Technologies

### 6.1 GitHub
- Source code repository
- Pipeline trigger via webhook

### 6.2 Jenkins
- CI/CD orchestrator
- Executes pipelines
- Controls workflow

### 6.3 Docker
- Solves environment mismatch
- Provides consistent runtime
- Ideal for microservices

### 6.4 AWS ECR
- Private Docker registry
- IAM‚Äëbased security
- ECS‚Äëoptimized

### 6.5 AWS ECS (Fargate)
- Container orchestration
- Serverless execution
- No EC2 management

### 6.6 Application Load Balancer
- Routes traffic
- Health checks
- Enables zero‚Äëdowntime deployments

---

## 7. High‚ÄëLevel Architecture
```
Developer ‚Üí GitHub ‚Üí Jenkins ‚Üí Docker ‚Üí ECR ‚Üí ECS (Fargate) ‚Üí ALB ‚Üí Users
```

---

## 8. Internal Data & Control Flow
1. Code push to GitHub
2. Webhook triggers Jenkins
3. Jenkins pulls code
4. Docker image built
5. Image pushed to ECR
6. ECS task definition updated
7. Fargate launches containers
8. ALB routes traffic
9. Users access app

---

## 9. Deployment Strategies & Zero Downtime

### Rolling Deployment
- Gradual replacement
- Default ECS behavior

### Blue‚ÄëGreen Deployment
- Two environments
- Safer but complex

### Zero‚ÄëDowntime Concept
Achieved using:
- Parallel containers
- ALB health checks
- Traffic shifting

---

## 10. Security Best Practices & Common Mistakes

### Best Practices
- IAM roles with least privilege
- No hardcoded credentials
- Private ECR
- Jenkins credentials store

### Common Mistakes
‚ö†Ô∏è Using AWS keys in code
‚ö†Ô∏è Using `latest` only
‚ö†Ô∏è Skipping health checks
‚ö†Ô∏è Manual ECS restarts

---

## 11. Implementation Guide (Step‚Äëby‚ÄëStep GUI)

---

### STEP 1: Create EC2 Instance for Jenkins Server

**Step 1.1: Open EC2 Launch Wizard**
- Go to **AWS Management Console** ‚Üí **EC2** ‚Üí **Instances** ‚Üí **Launch instance**

**Step 1.2: Configure Basic Instance Details**

| Setting | Value |
|---------|-------|
| **Name** | `jenkins-server` |
| **AMI** | Ubuntu Server 22.04 LTS (64-bit x86) |
| **Instance type** | `t2.micro` or `t3.micro` |

**Step 1.3: Key Pair Configuration**
- Select **Create new key pair**
- Name: `jenkins-key`
- Type: **RSA**
- Format: **.pem**
- **Download and save securely**

**Step 1.4: Network Settings**

Create a new security group with these inbound rules:

| Type | Protocol | Port | Source | Purpose |
|------|----------|------|--------|---------|
| SSH | TCP | 22 | Your IP | Secure login |
| Custom TCP | TCP | 8080 | 0.0.0.0/0 | Jenkins UI |
| HTTP | TCP | 80 | 0.0.0.0/0 | Application access |

**Step 1.5: Storage**
- Root volume: **20 GB**
- Type: **gp3**

**Step 1.6: Launch Instance**
- Click **Launch instance**

**Step 1.7: Verify EC2 Instance**
- Go to **EC2** ‚Üí **Instances**
- Verify:
  - Instance state: **Running**
  - Public IPv4 address: **Available**

---

### STEP 2: IAM Role Setup for Jenkins (EC2 ‚Üí ECR ‚Üí ECS)

**Step 2.1: Open IAM Role Creation Wizard**
- Go to **AWS Management Console** ‚Üí **IAM** ‚Üí **Roles** ‚Üí **Create role**

**Step 2.2: Select Trusted Entity**
- Trusted entity type: **AWS service**
- Use case: **EC2**
- Click **Next**

**Step 2.3: Attach Permission Policies**

Attach the following policies:
- ‚úÖ `AmazonEC2ContainerRegistryFullAccess`
- ‚úÖ `AmazonECS_FullAccess`

Click **Next**

**Step 2.4: Name and Create Role**

| Field | Value |
|-------|-------|
| Role name | `Jenkins-ECS-Role` |
| Description | IAM role for Jenkins EC2 to deploy Docker applications to ECS using ECR |

Click **Create role**

**Step 2.5: Attach IAM Role to Jenkins EC2**

1. Go to **EC2** ‚Üí **Instances**
2. Select `jenkins-server`
3. Click **Actions** ‚Üí **Security** ‚Üí **Modify IAM role**
4. Select `Jenkins-ECS-Role`
5. Click **Update IAM role**

**Step 2.6: Verify IAM Role**
- Go to **EC2** ‚Üí **Instances** ‚Üí `jenkins-server`
- Scroll to **IAM role** section
- Verify: `Jenkins-ECS-Role` is attached

---

### STEP 3: Prepare EC2 Server for Jenkins & CI/CD

**Step 3.1: Connect to EC2 via SSH**

Open terminal and run:
```bash
ssh -i jenkins-key.pem ubuntu@<EC2_PUBLIC_IP>
```

**Step 3.2: Update Operating System**
```bash
sudo apt update && sudo apt upgrade -y
```

**Step 3.3: Install Docker**
```bash
sudo apt install docker.io -y
```

**Step 3.4: Start & Enable Docker**
```bash
sudo systemctl start docker
sudo systemctl enable docker
```

**Step 3.5: Verify Docker**
```bash
docker --version
```

**Step 3.6: Allow Non-Root Docker Access**
```bash
sudo usermod -aG docker ubuntu
newgrp docker
```

**Step 3.7: Install AWS CLI**
```bash
sudo apt install unzip -y
curl "https://awscli.amazonaws.com/awscli-exe-linux-x86_64.zip" -o awscliv2.zip
unzip awscliv2.zip
sudo ./aws/install
```

**Step 3.8: Verify AWS CLI**
```bash
aws --version
```

**Step 3.9: Verify IAM Role Access**
```bash
aws sts get-caller-identity
```
Expected output shows the `Jenkins-ECS-Role` ARN.

---

### STEP 4: Install & Configure Jenkins on EC2

**Step 4.1: Install Java**
```bash
sudo apt install openjdk-17-jdk -y
```

**Step 4.2: Verify Java**
```bash
java -version
```

**Step 4.3: Add Jenkins Repository**
```bash
curl -fsSL https://pkg.jenkins.io/debian-stable/jenkins.io-2023.key | sudo tee /usr/share/keyrings/jenkins-keyring.asc > /dev/null

echo deb [signed-by=/usr/share/keyrings/jenkins-keyring.asc] https://pkg.jenkins.io/debian-stable binary/ | sudo tee /etc/apt/sources.list.d/jenkins.list
```

**Step 4.4: Install Jenkins**
```bash
sudo apt update
sudo apt install jenkins -y
```

**Step 4.5: Start & Enable Jenkins**
```bash
sudo systemctl start jenkins
sudo systemctl enable jenkins
```

**Step 4.6: Verify Jenkins Status**
```bash
sudo systemctl status jenkins
```

**Step 4.7: Access Jenkins Web UI**
- Open browser: `http://<EC2_PUBLIC_IP>:8080`

**Step 4.8: Unlock Jenkins**
```bash
sudo cat /var/lib/jenkins/secrets/initialAdminPassword
```
Copy the password and paste in browser.

**Step 4.9: Install Plugins**
- Click **Install suggested plugins**

**Step 4.10: Create Admin User**
- Fill in:
  - Username
  - Password
  - Full name
  - Email
- Click **Save and Continue**

**Step 4.11: Install Additional Plugins**

Go to: **Jenkins Dashboard** ‚Üí **Manage Jenkins** ‚Üí **Plugins** ‚Üí **Available Plugins**

Install:
- ‚úÖ **Git**
- ‚úÖ **Docker Pipeline**
- ‚úÖ **AWS Credentials**
- ‚úÖ **Pipeline: Stage View**

**Step 4.12: Add Jenkins to Docker Group**
```bash
sudo usermod -aG docker jenkins
sudo systemctl restart jenkins
```

---

### STEP 5: Clone Application Repository in Jenkins

**Step 5.1: Prepare GitHub Repository**
Ensure your repository contains:
- Application source code
- `Dockerfile`

**Step 5.2: Copy Repository URL**
- Go to GitHub repository
- Click **Code**
- Copy **HTTPS URL**

**Step 5.3: Create Jenkins Pipeline Job**

1. Go to **Jenkins Dashboard**
2. Click **New Item**
3. Enter name: `my-app-ci`
4. Select **Pipeline**
5. Click **OK**

**Step 5.4: Configure Source Code Management**

| Field | Value |
|-------|-------|
| **Pipeline Definition** | Pipeline script from SCM |
| **SCM** | Git |
| **Repository URL** | Your GitHub HTTPS URL |
| **Credentials** | None (for public repos) |
| **Branch** | `*/main` or `*/master` |
| **Script Path** | `Jenkinsfile` |

**Step 5.5: Save and Build**
- Click **Save**
- Click **Build Now**

**Step 5.6: Verify Build**
- Click the build number
- Click **Console Output**
- Verify: "Cloning repository" appears

---

### STEP 6: Build Docker Image using Jenkins Pipeline

**Step 6.1: Create Jenkinsfile in Your Repository**

Create a file named `Jenkinsfile` in your GitHub repository root:

```groovy
pipeline {
  agent any

  environment {
    AWS_REGION   = 'ap-south-1'  # Change to your region
    ECR_REPO_URI = '<ACCOUNT_ID>.dkr.ecr.<REGION>.amazonaws.com/my-app-repo'
    IMAGE_TAG    = "${BUILD_NUMBER}"
    ECS_CLUSTER  = 'my-cluster'
    ECS_SERVICE  = 'my-service'
  }

  stages {
    stage('Checkout Code') {
      steps {
        git branch: 'main',
            url: 'https://github.com/yourusername/your-repo.git'
      }
    }

    stage('Build Docker Image') {
      steps {
        sh '''
        docker build -t $ECR_REPO_URI:$IMAGE_TAG .
        docker tag $ECR_REPO_URI:$IMAGE_TAG $ECR_REPO_URI:latest
        '''
      }
    }

    stage('Push Image to ECR') {
      steps {
        sh '''
        aws ecr get-login-password --region $AWS_REGION | docker login --username AWS --password-stdin $ECR_REPO_URI
        docker push $ECR_REPO_URI:$IMAGE_TAG
        docker push $ECR_REPO_URI:latest
        '''
      }
    }

    stage('Deploy to ECS') {
      steps {
        sh '''
        aws ecs update-service --cluster $ECS_CLUSTER --service $ECS_SERVICE --force-new-deployment --region $AWS_REGION
        '''
      }
    }
  }
}
```

**Step 6.2: Update Jenkins Job**
- Go to `my-app-ci` job
- Click **Configure**
- Ensure **Script Path** is `Jenkinsfile`
- Click **Save**

**Step 6.3: Trigger Build**
- Click **Build Now**

**Step 6.4: Verify Docker Build**
- Check **Console Output**
- Look for: `Successfully tagged`

---

### STEP 7: Push Docker Image to Amazon ECR

**Step 7.1: Create ECR Repository**

1. Go to **AWS Management Console** ‚Üí **Amazon ECR** ‚Üí **Repositories**
2. Click **Create repository**

| Field | Value |
|-------|-------|
| **Repository name** | `my-app-repo` |
| **Visibility** | Private |
| **Tag immutability** | Disabled |

3. Click **Create repository**

**Step 7.2: Note Repository URI**
```
<ACCOUNT_ID>.dkr.ecr.<REGION>.amazonaws.com/my-app-repo
```

**Step 7.3: Update Jenkinsfile**
Replace `<ACCOUNT_ID>` and `<REGION>` with your actual values.

**Step 7.4: Trigger Pipeline**
- Go to Jenkins job `my-app-ci`
- Click **Build Now**

**Step 7.5: Verify in ECR**

1. Go to **Amazon ECR** ‚Üí **Repositories** ‚Üí `my-app-repo`
2. Verify images appear with tags:
   - `latest`
   - `<BUILD_NUMBER>`

---

### STEP 8: Create ECS Cluster (AWS Fargate)

**Step 8.1: Open ECS Console**
- Go to **AWS Management Console** ‚Üí **Amazon ECS**

**Step 8.2: Create Cluster**
- Click **Clusters**
- Click **Create cluster**

**Step 8.3: Configure Cluster**

| Field | Value |
|-------|-------|
| **Cluster template** | AWS Fargate |
| **Cluster name** | `my-cluster` |
| **VPC** | Default VPC |
| **Subnets** | Default subnets |

**Step 8.4: Create Cluster**
- Click **Create**

**Step 8.5: Verify Cluster**
- Go to **ECS** ‚Üí **Clusters** ‚Üí `my-cluster`
- Status: **Active**

---

### STEP 9: Create ECS Task Definition (Fargate)

**Step 9.1: Open Task Definition Wizard**
- Go to **Amazon ECS** ‚Üí **Task Definitions**
- Click **Create new task definition**

**Step 9.2: Select Launch Type**
- Select: **AWS Fargate**
- Click **Next**

**Step 9.3: Configure Task Definition**

| Field | Value |
|-------|-------|
| **Task definition family** | `my-task` |
| **Operating system** | Linux |
| **Task execution role** | `ecsTaskExecutionRole` |
| **CPU** | 0.25 vCPU |
| **Memory** | 0.5 GB |

**Step 9.4: Add Container**

Click **Add container**

| Field | Value |
|-------|-------|
| **Container name** | `my-container` |
| **Image URI** | `<ACCOUNT_ID>.dkr.ecr.<REGION>.amazonaws.com/my-app-repo:latest` |
| **Essential** | Yes |

**Port Mappings:**

| Field | Value |
|-------|-------|
| **Container port** | 80 |
| **Protocol** | TCP |

**Logging:**

| Field | Value |
|-------|-------|
| **Log driver** | awslogs |
| **Log group** | `/ecs/my-task` |
| **Region** | ap-south-1 |
| **Stream prefix** | `ecs` |

**Step 9.5: Create Task Definition**
- Click **Create**

**Step 9.6: Verify**
- Go to **Task Definitions** ‚Üí `my-task`
- Revision `:1` should be **ACTIVE**

---

### STEP 10: Create ECS Service (AWS Fargate)

**Step 10.1: Open ECS Cluster**
- Go to **Amazon ECS** ‚Üí **Clusters** ‚Üí `my-cluster`

**Step 10.2: Create Service**
- Click **Services** tab
- Click **Create**

**Step 10.3: Configure Service Basics**

| Field | Value |
|-------|-------|
| **Launch type** | Fargate |
| **Task Definition Family** | `my-task` |
| **Revision** | Latest (`:1`) |
| **Service name** | `my-service` |
| **Desired tasks** | `1` |

**Step 10.4: Networking Configuration**

| Field | Value |
|-------|-------|
| **VPC** | Same as cluster |
| **Subnets** | Select at least one |
| **Security group** | Create new or select existing with port 80 |
| **Public IP** | ENABLED (for testing) |

**Step 10.5: Load Balancer**
- Select: **No load balancer** (we'll add later)
- Click **Create service**

**Step 10.6: Verify Service**

1. Go to **Services** ‚Üí `my-service`
2. Verify:
   - Desired tasks: **1**
   - Running tasks: **1**
   - Status: **ACTIVE**

---

### STEP 11: Create Application Load Balancer (ALB)

**Step 11.1: Open EC2 Load Balancer Console**
- Go to **AWS Management Console** ‚Üí **EC2** ‚Üí **Load Balancers**

**Step 11.2: Create Load Balancer**
- Click **Create Load Balancer**
- Select **Application Load Balancer**
- Click **Create**

**Step 11.3: Configure ALB Basics**

| Field | Value |
|-------|-------|
| **Name** | `my-alb` |
| **Scheme** | Internet-facing |
| **IP address type** | IPv4 |

**Step 11.4: Network Mapping**

| Field | Value |
|-------|-------|
| **VPC** | Same as ECS cluster |
| **Subnets** | Select at least two subnets |

**Step 11.5: Security Group**

Create new security group:

| Rule | Port | Source |
|------|------|--------|
| HTTP | 80 | 0.0.0.0/0 |

**Step 11.6: Listeners and Routing**

| Field | Value |
|-------|-------|
| **Listener Protocol** | HTTP |
| **Listener Port** | 80 |
| **Default action** | Create target group (will configure next) |

**Step 11.7: Create Load Balancer**
- Click **Create load balancer**

**Step 11.8: Verify ALB**
- Go to **EC2** ‚Üí **Load Balancers** ‚Üí `my-alb`
- Status: **Active**
- Note the **DNS name**

---

### STEP 12: Create Target Group for ECS Service

**Step 12.1: Open Target Group Creation Wizard**
- Go to **EC2** ‚Üí **Target Groups**
- Click **Create target group**

**Step 12.2: Choose Target Type**

| Field | Value |
|-------|-------|
| **Target type** | **IP addresses** |

**Step 12.3: Configure Target Group**

| Field | Value |
|-------|-------|
| **Target group name** | `my-target-group` |
| **Protocol** | HTTP |
| **Port** | 80 |
| **VPC** | Same as ECS cluster |

**Step 12.4: Configure Health Checks**

| Field | Value |
|-------|-------|
| **Health check protocol** | HTTP |
| **Health check path** | `/` |
| **Port** | Traffic port |

**Advanced health check settings** (keep defaults):
- Healthy threshold: 5
- Unhealthy threshold: 2
- Timeout: 5 seconds
- Interval: 30 seconds

**Step 12.5: Register Targets**
- Skip (do not register any targets)
- Click **Next**

**Step 12.6: Create Target Group**
- Click **Create target group**

**Step 12.7: Verify**
- Go to **Target Groups** ‚Üí `my-target-group`
- Targets: **0** (expected)

---

### STEP 13: Attach Target Group to ECS Service (Enable Traffic Flow)

**Step 13.1: Open ECS Service**
- Go to **Amazon ECS** ‚Üí **Clusters** ‚Üí `my-cluster` ‚Üí **Services** ‚Üí `my-service`

**Step 13.2: Update Service**
- Click **Update**

**Step 13.3: Configure Load Balancer Integration**

Scroll to **Load balancing** section:

| Field | Value |
|-------|-------|
| **Load balancer type** | Application Load Balancer |
| **Load balancer** | `my-alb` |
| **Listener** | HTTP : 80 |

**Container Mapping:**

| Field | Value |
|-------|-------|
| **Container name** | `my-container` |
| **Container port** | 80 |
| **Target group** | `my-target-group` |

**Step 13.4: Complete Service Update**
- Keep all other settings as default
- Click **Update service**

**Step 13.5: Monitor Deployment**
- Go to **Services** ‚Üí `my-service`
- Watch deployment status
- Wait for tasks to become **RUNNING**

**Step 13.6: Verify Target Registration**

1. Go to **EC2** ‚Üí **Target Groups** ‚Üí `my-target-group`
2. Click **Targets** tab
3. Verify:
   - Target (IP) appears
   - Status: **healthy**

**Step 13.7: Test Application**

1. Go to **EC2** ‚Üí **Load Balancers** ‚Üí `my-alb`
2. Copy **DNS name** (e.g., `my-alb-123456.ap-south-1.elb.amazonaws.com`)
3. Open in browser: `http://<ALB_DNS_NAME>`
4. üéâ **Your application should load!**

**Step 13.8: Test CI/CD Pipeline**
1. Make a change to your application code
2. Push to GitHub
3. Go to Jenkins and trigger a build (or set up webhook)
4. Watch the pipeline execute automatically
5. Refresh browser to see changes

---

**üéØ Congratulations! You've built a production-grade CI/CD pipeline that mirrors real industry practices.**
